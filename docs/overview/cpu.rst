.. _using_cpu:

========================
Using a Classical Solver
========================

You might use a classical solver while developing your code or on a small version of
your problem to verify your code.
To solve a problem classically on your local machine, you configure a classical solver,
either one of those included in the Ocean tools or your own.

Examples
~~~~~~~~

Among several samplers provided in the :doc:`dimod </docs_dimod/sdk_index>`
tool for testing your code locally, is the :code:`ExactSolver()` that calculates the energy of all
possible samples for a given problem. This example solves a two-variable Ising model
classically on your local machine.

.. code-block:: python

   >>> import dimod
   >>> solver = dimod.ExactSolver()
   >>> response = solver.sample_ising({'a': -0.5, 'b': 1.0}, {('a', 'b'): -1})
   >>> response.data_vectors['energy']
   array([-1.5, -0.5, -0.5,  2.5])

This example solves the previous problem using the :doc:`dwave_neal </docs_neal/sdk_index>`
simulated annealing sampler.
The two samples requested and generated by this classical solver on your local machine
vary by execution.

.. code-block:: python

   >>> import neal
   >>> solver = neal.SimulatedAnnealingSampler()
   >>> response = solver.sample_ising({'a': -0.5, 'b': 1.0}, {('a', 'b'): -1}, num_reads=2)
   >>> response.data_vectors['energy']       # doctest: +SKIP
   array([-1.5, -0.5])

If you use a classical solver running locally on your CPU, a
single sample might provide the optimal solution.

Ocean's :doc:`dimod </docs_dimod/sdk_index>` tool provides a reference solver
that calculates the values of a BQM (its "energy") for all possible assignments of variables.
Such a sampler can solve a small three-variable problem like the AND gate created above.

.. code-block:: python

    >>> from dimod.reference.samplers import ExactSolver
    >>> sampler = ExactSolver()
    >>> response = sampler.sample(bqm)    # doctest: +SKIP
    >>> for datum in response.data(['sample', 'energy']):     # doctest: +SKIP
    ...    print(datum.sample, datum.energy)
    ...
    {'x1': 0, 'x2': 0, 'y1': 0} -1.5
    {'x1': 1, 'x2': 0, 'y1': 0} -1.5
    {'x1': 0, 'x2': 1, 'y1': 0} -1.5
    {'x1': 1, 'x2': 1, 'y1': 1} -1.5
    {'x1': 1, 'x2': 1, 'y1': 0} 0.5
    {'x1': 0, 'x2': 1, 'y1': 1} 0.5
    {'x1': 1, 'x2': 0, 'y1': 1} 0.5
    {'x1': 0, 'x2': 0, 'y1': 1} 4.5

Note that the first four samples are the valid states of the AND gate and have
lower values than the second four, which represent invalid states.
